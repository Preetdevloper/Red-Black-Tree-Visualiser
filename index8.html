<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- CUSTOM CSS REMAINING FOR THEME/ANIMATION/CANVAS --- */

        /* Define color variables (Tailwind needs custom colors defined or overridden) */
        :root {
            --bg-primary: #1a1a2e; /* Deep dark blue-purple */
            --bg-secondary: #22223b; /* Card background */
            --bg-tertiary: #4a4e69; /* Input/Step background */
            --text-primary: #f0f0f0;
            --text-secondary: #dcdcdc;
            --accent: #00bcd4; /* Vibrant Teal */
            --accent-hover: #008ba3;
            --border: #6b6b8b;
            --red-node: #ff6b6b; /* Vibrant Red */
            --black-node: #3d3b5b; /* Dark purple-ish black */
            --null-node: #8d99ae;
            
            /* Custom Button Colors */
            --insert-btn: #38a169; 
            --delete-btn: #d9534f;
            --clear-btn: #5bc0de;
            --step-btn: #ffc107; 

            /* Stat Text Color for Dark Theme */
            --stat-value-color-dark: var(--red-node);
        }

        /* Light Theme override for visibility */
        .light-theme {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --accent: #00bcd4;
            --accent-hover: #008ba3;
            --border: #ced4da;
            --red-node: #ff6b6b;
            --black-node: #343a40;
            --null-node: #adb5bd;
            
            /* Stat Text Color for Light Theme (Fixing visibility) */
            --stat-value-color-light: #1a1a1a; 
        }

        /* FIX: Apply the primary background color to the body */
        body {
            background-color: var(--bg-primary); 
            transition: background-color 0.3s;
        }

        /* Custom styles not easily done with Tailwind utilities */
        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--border);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle.active { background: var(--accent); }
        .toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle.active::after { transform: translateX(24px); }

        .step-item.active { border-color: var(--step-btn) !important; background: #4a4e6980; }
        .violation { color: var(--red-node); font-weight: bold; }
        
        /* Styling the header gradient, which Tailwind can't easily handle with variables */
        .header-gradient {
            background: linear-gradient(135deg, var(--accent), #45f3ff); 
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* FIX: Ensure stat values are visible in both themes */
        .stat-item .value {
             color: var(--stat-value-color-dark);
        }
        .light-theme .stat-item .value {
             color: var(--stat-value-color-light);
        }

        /* FIX: Adjusted height for container alignment */
        .steps-container {
             min-height: 250px; 
             max-height: 100%;
        }


        /* Responsive adjustments for mobile */
        @media (max-width: 1024px) {
            .main-content { grid-template-columns: 1fr; }
            .sidebar { max-height: 400px; }
            #tree-canvas { height: 400px; }
        }
        @media (max-width: 768px) {
            .container { padding: 10px; }
        }
    </style>
</head>
<body class="bg-primary text-primary font-sans transition-colors duration-300">
    <div class="container max-w-7xl mx-auto p-5">
        <header class="text-center mb-5 p-4 rounded-xl bg-secondary shadow-lg">
            <h1 class="text-3xl sm:text-4xl font-extrabold mb-1 header-gradient">
                Red-Black Tree Visualizer
            </h1>
            <p class="text-text-secondary" style="color:#7e78ed">Interactive visualization tool for efficient self-balancing trees</p>
        </header>

        <div class="controls flex flex-wrap gap-4 justify-center items-center mb-5 p-5 rounded-xl bg-secondary shadow-lg">
            
            <input type="number" id="nodeValue" placeholder="Value" min="1" max="999" 
                   class="p-2 border-2 rounded-lg bg-tertiary text-primary w-24 focus:outline-none focus:ring-2 focus:ring-accent focus:border-accent"
                   style="border-color: var(--border);">
            
            <button onclick="insertNode()" 
                    class="py-2 px-4 rounded-lg font-semibold transition-all duration-300 transform hover:-translate-y-0.5 hover:shadow-xl"
                    style="background: var(--insert-btn); color: white;">Insert</button>
            
            <button onclick="deleteNode()" 
                    class="py-2 px-4 rounded-lg font-semibold transition-all duration-300 transform hover:-translate-y-0.5 hover:shadow-xl"
                    style="background: var(--delete-btn); color: white;">Delete</button>
            
            <button onclick="clearTree()" 
                    class="py-2 px-4 rounded-lg font-semibold transition-all duration-300 transform hover:-translate-y-0.5 hover:shadow-xl"
                    style="background: var(--clear-btn); color: white;">Clear Tree</button>

            <div class="animation-controller flex flex-col gap-2 p-3 rounded-lg min-w-64" style="border: 1px solid var(--border); background: var(--bg-tertiary);">
                <div class="animation-buttons flex justify-between gap-2">
                    <button class="py-2 px-3 rounded-lg font-semibold transition-all duration-300 text-sm" style="width: 50%; background: var(--step-btn); color: black;" onclick="prevStep()">&lt;&lt; Prev Step</button>
                    <button class="py-2 px-3 rounded-lg font-semibold transition-all duration-300 text-sm" style="width: 50%; background: var(--step-btn); color: black;" onclick="nextStep()">Next Step &gt;&gt;</button>
                </div>
                <div class="animation-slider flex items-center gap-2">
                    <span class="text-sm" style="color: var(--text-secondary);">Speed:</span>
                    <input type="range" id="animationSpeed" min="1" max="10" value="5" class="flex-grow">
                </div>
            </div>

            <div class="toggle-group flex gap-2 items-center">
                <span class="text-sm">Show Null Nodes</span>
                <div class="toggle" id="nullToggle" onclick="toggleNullNodes()"></div>
            </div>
            <div class="toggle-group flex gap-2 items-center">
                <span role="img" aria-label="dark mode">üåô</span>
                <div class="toggle" id="themeToggle" onclick="toggleTheme()"></div>
                <span role="img" aria-label="light mode">‚òÄÔ∏è</span>
            </div>
        </div>
        
        <div class="main-content grid grid-cols-1 lg:grid-cols-[1fr_350px] gap-5">
            
            <canvas id="tree-canvas" class="w-full h-[600px] bg-secondary rounded-xl shadow-lg"></canvas>

            <div class="sidebar flex flex-col gap-5 min-h-[600px] lg:min-h-0">
                
                <div class="info-card bg-secondary p-5 rounded-xl shadow-lg">
                    <h3 class="text-lg font-semibold mb-3 border-b-2 pb-1" style="color: var(--accent); border-color: var(--border);">
                        üìä Tree Statistics
                    </h3>
                    <div class="stats-grid grid grid-cols-2 gap-3 mb-4">
                        <div class="stat-item flex flex-col items-center justify-center p-2 rounded-lg" style="background: var(--bg-tertiary); border: 1px solid var(--border);">
                            <span class="label text-xs" style="color: var(--text-secondary);">Total Nodes</span>
                            <span class="value text-xl font-bold" id="nodeCount">0</span>
                        </div>
                        <div class="stat-item flex flex-col items-center justify-center p-2 rounded-lg" style="background: var(--bg-tertiary); border: 1px solid var(--border);">
                            <span class="label text-xs" style="color: var(--text-secondary);">Tree Height</span>
                            <span class="value text-xl font-bold" id="treeHeight">0</span>
                        </div>
                        <div class="stat-item flex flex-col items-center justify-center p-2 rounded-lg" style="background: var(--bg-tertiary); border: 1px solid var(--border);">
                            <span class="label text-xs" style="color: var(--text-secondary);">Black Height</span>
                            <span class="value text-xl font-bold" id="blackHeight">0</span>
                        </div>
                        <div class="stat-item flex flex-col items-center justify-center p-2 rounded-lg" style="background: var(--bg-tertiary); border: 1px solid var(--border);">
                            <span class="label text-xs" style="color: var(--text-secondary);">Max Nodes @Height</span>
                            <span class="value text-lg font-bold" style="color: var(--accent);">2<sup>h</sup>-1
                            </span>
                        </div>
                    </div>
                    
                    <h3 class="text-lg font-semibold mb-3 border-b-2 pb-1" style="color: var(--accent); border-color: var(--border);">
                        üí° RB Tree Guarantees
                    </h3>
                    <ul class="list-none p-0 text-sm">
                        <li class="pb-2 border-b-0" style="color: var(--text-secondary);">1. Every node is either red or black</li>
                        <li class="pb-2 border-b-0" style="color: var(--text-secondary);">2. Root is always black</li>
                        <li class="pb-2 border-b-0" style="color: var(--text-secondary);">3. All null leaves are black</li>
                        <li class="pb-2 border-b-0" style="color: var(--text-secondary);">4. Red nodes have black children</li>
                        <li class="pb-2 border-b-0" style="color: var(--text-secondary);">5. All paths have same black height</li>
                    </ul>
                    <div class="tree-formula mt-3 pt-2 border-t dashed italic text-xs" style="color: var(--text-secondary); border-color: var(--border);">
                        Tree Height ‚â§ 2 √ó Log<sub>2</sub>(n+1)
                    </div>
                </div>

                <div class="steps-container bg-secondary p-5 rounded-xl shadow-lg flex-grow overflow-y-auto" style="min-height: 250px;">
                    <div class="steps-title text-lg font-semibold mb-3" style="color: var(--accent);">
                        ‚û°Ô∏è Operation Steps
                    </div>
                    <div id="stepsDisplay" style="color: #7e78ed;">Waiting for operation...</div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Global variable for autoplay control
        let fixupInterval = null;

        // --- Core Node and Tree Classes ---
        class RBNode {
            constructor(value) {
                this.value = value;
                this.color = 'RED';
                this.left = null;
                this.right = null;
                this.parent = null;
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
            }

            getSnapshot() {
                return {
                    value: this.value,
                    color: this.color,
                    left: this.left ? this.left.getSnapshot() : null,
                    right: this.right ? this.right.getSnapshot() : null,
                    x: this.x,
                    y: this.y,
                    targetX: this.targetX,
                    targetY: this.targetY,
                };
            }
        }

        class RedBlackTree {
            constructor() {
                this.root = null;
                this.history = []; 
                this.currentStepIndex = -1; 
                this.nodeToFix = null; 
                this.fixupInProgress = false;
                this.fixupType = null; // 'insert' or 'delete'
            }
            
            buildTreeFromSnapshot(snapshot, parent = null) {
                if (!snapshot) return null;

                const node = new RBNode(snapshot.value);
                node.color = snapshot.color;
                node.parent = parent;
                node.x = snapshot.x || 0;
                node.y = snapshot.y || 0;
                node.targetX = snapshot.targetX || 0;
                node.targetY = snapshot.targetY || 0;

                node.left = this.buildTreeFromSnapshot(snapshot.left, node);
                node.right = this.buildTreeFromSnapshot(snapshot.right, node);

                return node;
            }

            saveState(stepMessage) {
                if (this.currentStepIndex !== this.history.length - 1) {
                    this.history.splice(this.currentStepIndex + 1);
                }

                const treeSnapshot = this.root ? this.root.getSnapshot() : null;
                this.history.push({
                    rootSnapshot: treeSnapshot,
                    stepMessage: stepMessage,
                });
                this.currentStepIndex = this.history.length - 1;
            }

            loadState(index) {
                if (fixupInterval) clearInterval(fixupInterval); // Stop autoplay on manual step
                this.fixupInProgress = false;
                
                if (index < 0 || index >= this.history.length) return false;

                const { rootSnapshot } = this.history[index];

                this.root = this.buildTreeFromSnapshot(rootSnapshot);
                this.currentStepIndex = index;
                
                this.updateDisplay();
                return true;
            }
            
            updateDisplay(scrollToBottom = false) {
                 document.getElementById('treeHeight').textContent = this.getHeight();
                 document.getElementById('nodeCount').textContent = this.countNodes(this.root);
                 
                 const bh = this.getBlackHeight(this.root);
                 document.getElementById('blackHeight').textContent = (bh === 'ERROR' ? 'INVALID' : bh);
            
                 const stepsDisplay = document.getElementById('stepsDisplay');
                 
                 const historySteps = this.history.map((h, index) => {
                     const step = h.stepMessage;
                     const isViolation = step.toLowerCase().includes('case') || step.toLowerCase().includes('fix-up') || step.toLowerCase().includes('recolor');
                     const isActive = index === this.currentStepIndex ? 'active' : '';
                     return `<div class="step-item ${isViolation ? 'violation' : ''} ${isActive}">${step}</div>`;
                 }).join('');

                 if (historySteps.length === 0) {
                      stepsDisplay.innerHTML = 'Waiting for operation...';
                 } else {
                      stepsDisplay.innerHTML = historySteps;
                 }
            
                 if (scrollToBottom) {
                      stepsDisplay.scrollTop = stepsDisplay.scrollHeight;
                 }
            
                 animateTree();
            }

            // --- RB Tree Utility Methods (Unchanged) ---
            countNodes(node) {
                if (!node) return 0;
                return 1 + this.countNodes(node.left) + this.countNodes(node.right);
            }

            getHeight(node = this.root) {
                if (!node) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }

            getBlackHeight(node) {
                if (!node) return 1; 
                const leftBH = this.getBlackHeight(node.left);
                const rightBH = this.getBlackHeight(node.right);
                
                if (leftBH === 'ERROR' || rightBH === 'ERROR' || leftBH !== rightBH) {
                    return 'ERROR';
                }
                
                const bh = leftBH + (node.color === 'BLACK' ? 1 : 0);
                return bh;
            }

            // --- Rotation Helpers (Unchanged) ---
            rotateLeft(node) {
                const rightChild = node.right;
                node.right = rightChild.left;
                if (rightChild.left) { rightChild.left.parent = node; }
                rightChild.parent = node.parent;
                if (!node.parent) { this.root = rightChild; } 
                else if (node === node.parent.left) { node.parent.left = rightChild; } 
                else { node.parent.right = rightChild; }
                rightChild.left = node;
                node.parent = rightChild;
            }

            rotateRight(node) {
                const leftChild = node.left;
                node.left = leftChild.right;
                if (leftChild.right) { leftChild.right.parent = node; }
                leftChild.parent = node.parent;
                if (!node.parent) { this.root = leftChild; } 
                else if (node === node.parent.right) { node.parent.right = leftChild; } 
                else { node.parent.left = leftChild; }
                leftChild.right = node;
                node.parent = leftChild;
            }
            
            // --- Insertion Logic ---
            insert(value) {
                this.history = []; 
                this.fixupType = 'insert';
                this.saveState(`Starting insert for: ${value}`);

                const newNode = new RBNode(value);
                this.nodeToFix = newNode;

                if (!this.root) {
                    this.root = newNode;
                    this.root.color = 'BLACK';
                    this.saveState('Tree was empty, inserted as black root. Fix-up complete.');
                    this.nodeToFix = null;
                    return;
                }

                let current = this.root;
                let parent = null;

                while (current) {
                    parent = current;
                    if (value < current.value) {
                        current = current.left;
                    } else if (value > current.value) {
                        current = current.right;
                    } else {
                        this.saveState('Value already exists in tree (No change)');
                        this.nodeToFix = null;
                        return;
                    }
                }

                newNode.parent = parent;
                if (value < parent.value) {
                    parent.left = newNode;
                } else {
                    parent.right = newNode;
                }
                
                this.saveState(`Inserted ${value} as RED node. Starting fix-up.`);
                
                // AUTOPLAY: Start the fix-up process automatically
                fixupInterval = setInterval(() => {
                    if (this.fixupInProgress || !animationComplete) return; 

                    this.fixupInProgress = true;
                    if (!this.runFixStep()) {
                        clearInterval(fixupInterval);
                        fixupInterval = null;
                    }
                    this.fixupInProgress = false;
                }, 500); // 500ms delay between steps
            }

            // --- Deletion Logic ---
            delete(value) {
                this.history = [];
                this.fixupType = 'delete';
                this.saveState(`Starting delete for: ${value}`);
                
                const z = this.search(this.root, value);
                if (!z) {
                    this.saveState('Value not found in tree (No change)');
                    this.nodeToFix = null;
                    return;
                }
                
                let y = z;
                let yOriginalColor = y.color;
                let xParent = null; 
                let xSide = null; // To track if the double-black was left or right child of xParent

                if (!z.left) {
                    xParent = z.parent;
                    xSide = (z === z.parent?.left) ? 'left' : 'right';
                    this.transplant(z, z.right);
                } else if (!z.right) {
                    xParent = z.parent;
                    xSide = (z === z.parent?.left) ? 'left' : 'right';
                    this.transplant(z, z.left);
                } else {
                    y = this.minimum(z.right);
                    yOriginalColor = y.color;
                    xParent = y.parent;
                    xSide = 'right'; // Successor's placeholder child is always right
                    
                    if (y.parent !== z) {
                        this.transplant(y, y.right);
                        y.right = z.right;
                        if (y.right) y.right.parent = y;
                    }
                    
                    this.transplant(z, y);
                    y.left = z.left;
                    y.left.parent = y;
                    y.color = z.color;
                }
                
                if (yOriginalColor === 'BLACK') {
                    // Create a placeholder object to represent the double-black NIL node if needed
                    const nilPlaceholder = { 
                        value: 'NIL', 
                        color: 'BLACK', 
                        parent: xParent,
                        isLeft: xSide === 'left',
                        isPlaceholder: true 
                    };
                    
                    this.nodeToFix = nilPlaceholder;
                    this.saveState(`Deleted BLACK node. Starting double-black fix-up on parent ${xParent ? xParent.value : 'root'}.`);
                    
                    // AUTOPLAY: Start the fix-up process
                    fixupInterval = setInterval(() => {
                        if (this.fixupInProgress || !animationComplete) return; 

                        this.fixupInProgress = true;
                        if (!this.runFixStep()) {
                            clearInterval(fixupInterval);
                            fixupInterval = null;
                        }
                        this.fixupInProgress = false;
                    }, 500); 
                } else {
                    this.nodeToFix = null;
                    this.saveState(`Deleted RED node ${z.value}. Fix-up complete.`);
                }
            }

            // --- Universal Fix-up Dispatcher ---
            runFixStep() {
                if (!this.nodeToFix) return false;
                
                if (this.fixupType === 'insert') {
                    return this.fixInsertStep();
                } else if (this.fixupType === 'delete') {
                    return this.fixDeleteStep();
                }
                return false;
            }

            // --- Step-by-Step Fix Insert (Core Logic) ---
            fixInsertStep() {
                if (!this.nodeToFix) return false;
                let node = this.search(this.root, this.nodeToFix.value) || this.nodeToFix; 
                
                if (!node || !node.parent || node.parent.color === 'BLACK') {
                    
                    if (this.root && this.root.color === 'RED') {
                        this.root.color = 'BLACK';
                        this.saveState('Final: Root recolored BLACK. Fix-up complete.');
                    } else {
                        this.saveState(`Property 4 satisfied. Fix-up complete.`);
                    }

                    this.nodeToFix = null;
                    this.updateDisplay();
                    return false;
                }

                if (node.parent.color === 'RED') {
                    if (!node.parent.parent) return false; 

                    const grandparent = node.parent.parent;
                    const isParentLeft = node.parent === grandparent.left;
                    const uncle = isParentLeft ? grandparent.right : grandparent.left;

                    if (uncle && uncle.color === 'RED') {
                        // Case 1
                        node.parent.color = 'BLACK';
                        if (uncle) uncle.color = 'BLACK';
                        grandparent.color = 'RED';
                        this.nodeToFix = grandparent;
                        this.saveState(`Case 1: Recolor parent, uncle, and grandparent ${this.nodeToFix.value}.`);
                        this.updateDisplay();
                        return true;

                    } else { // Uncle is BLACK or null
                        if (isParentLeft && node === node.parent.right) {
                            // Case 2 (Left-Right/Triangle case)
                            this.rotateLeft(node.parent); 
                            this.nodeToFix = node.left; 
                            this.saveState(`Case 2: Left-Rotate on parent ${node.value}. Transition to Case 3.`);
                            node = this.search(this.root, this.nodeToFix.value) || this.nodeToFix; 
                        } else if (!isParentLeft && node === node.parent.left) {
                             // Case 2 (Right-Left/Triangle case)
                            this.rotateRight(node.parent);
                            this.nodeToFix = node.right;
                            this.saveState(`Case 2: Right-Rotate on parent ${node.value}. Transition to Case 3.`);
                            node = this.search(this.root, this.nodeToFix.value) || this.nodeToFix;
                        }
                        
                        // Case 3 (Line case, or fall-through from Case 2)
                        node.parent.color = 'BLACK';
                        node.parent.parent.color = 'RED';
                        
                        if (node.parent === node.parent.parent.left) {
                            this.rotateRight(node.parent.parent); 
                            this.saveState(`Case 3: Right-Rotate on grandparent ${node.parent.value}. Fix-up complete.`);
                        } else {
                            this.rotateLeft(node.parent.parent); 
                            this.saveState(`Case 3: Left-Rotate on grandparent ${node.parent.value}. Fix-up complete.`);
                        }

                        this.nodeToFix = null;
                        this.updateDisplay();
                        return false;
                    }
                }
                
                return false;
            }
            
            // --- Step-by-Step Fix Delete (Core Logic) ---
            fixDeleteStep() {
                if (!this.nodeToFix) return false;
                
                let x = this.search(this.root, this.nodeToFix.value) || this.nodeToFix; // x is the double-black node/placeholder
                let parent = x.parent || this.nodeToFix.parent; // Parent of the double-black node
                
                if (x === this.root || !parent) { // Termination condition
                    if (this.root.color === 'RED') this.root.color = 'BLACK';
                    this.nodeToFix = null;
                    this.saveState(`Fix-up complete: Reached root. Final root color is BLACK.`);
                    this.updateDisplay();
                    return false;
                }

                // Node is either the NIL object or a real node (which is BLACK)
                const isXLeft = parent.left === x || (x.isPlaceholder && x.isLeft);
                let sibling = isXLeft ? parent.right : parent.left;
                
                // If sibling is null, the tree structure is broken, terminate
                if (!sibling) { 
                    this.nodeToFix = null;
                    return false; 
                }

                // Case 1: Sibling is RED
                if (sibling.color === 'RED') {
                    sibling.color = 'BLACK';
                    parent.color = 'RED';
                    if (isXLeft) {
                        this.rotateLeft(parent);
                        this.saveState(`Case 1: Sibling ${sibling.value} is RED. Left-Rotate on parent.`);
                    } else {
                        this.rotateRight(parent);
                        this.saveState(`Case 1: Sibling ${sibling.value} is RED. Right-Rotate on parent.`);
                    }
                    this.updateDisplay();
                    return true;
                }
                
                // Sibling is BLACK from here on.
                const sLeft = sibling.left;
                const sRight = sibling.right;

                // Case 2: Sibling is BLACK, both children are BLACK
                if ((!sLeft || sLeft.color === 'BLACK') && (!sRight || sRight.color === 'BLACK')) {
                    sibling.color = 'RED';
                    
                    // If parent is RED, we fix color and terminate. If BLACK, propagate.
                    if (parent.color === 'RED') {
                        parent.color = 'BLACK';
                        this.nodeToFix = null; // Terminate
                        this.saveState(`Case 2: Sibling and children BLACK. Parent ${parent.value} was RED, recolored BLACK. Fix-up complete.`);
                        this.updateDisplay();
                        return false;
                    } else {
                        this.nodeToFix = parent; // Propagate double-black to parent
                        this.saveState(`Case 2: Sibling and children BLACK. Recolor sibling RED. Propagate double-black to parent ${parent.value}.`);
                        this.updateDisplay();
                        return true; // Continue loop at parent
                    }
                }

                // Case 3/4 involves colored children. Recalculate sibling pointers after potential Case 3 rotation.

                // Case 3: Sibling is BLACK, near child is RED, far child is BLACK
                if (isXLeft && sLeft && sLeft.color === 'RED' && (!sRight || sRight.color === 'BLACK')) {
                    sLeft.color = 'BLACK';
                    sibling.color = 'RED';
                    this.rotateRight(sibling);
                    this.saveState(`Case 3: Sibling near child ${sLeft.value} is RED. Right-Rotate on sibling.`);
                    this.updateDisplay();
                    return true; // Loop continues, will hit Case 4 next
                } else if (!isXLeft && sRight && sRight.color === 'RED' && (!sLeft || sLeft.color === 'BLACK')) {
                    sRight.color = 'BLACK';
                    sibling.color = 'RED';
                    this.rotateLeft(sibling);
                    this.saveState(`Case 3: Sibling near child ${sRight.value} is RED. Left-Rotate on sibling.`);
                    this.updateDisplay();
                    return true; // Loop continues, will hit Case 4 next
                }
                
                // Case 4: Sibling is BLACK, far child is RED (Termination)
                
                // Re-fetch sibling pointers if Case 3 occurred immediately prior to ensure correct rotation
                sibling = isXLeft ? parent.right : parent.left;
                
                if (isXLeft) {
                    sibling.color = parent.color;
                    parent.color = 'BLACK';
                    if (sibling.right) sibling.right.color = 'BLACK';
                    this.rotateLeft(parent);
                    this.saveState(`Case 4: Sibling far child is RED. Final rotation (Left-Rotate on parent). Fix-up complete.`);
                } else {
                    sibling.color = parent.color;
                    parent.color = 'BLACK';
                    if (sibling.left) sibling.left.color = 'BLACK';
                    this.rotateRight(parent);
                    this.saveState(`Case 4: Sibling far child is RED. Final rotation (Right-Rotate on parent). Fix-up complete.`);
                }

                this.nodeToFix = null;
                this.updateDisplay();
                return false;
            }


            // --- Unchanged structural methods ---
            transplant(u, v) {
                if (!u.parent) { this.root = v; } 
                else if (u === u.parent.left) { u.parent.left = v; } 
                else { u.parent.right = v; }
                if (v) v.parent = u.parent;
            }

            minimum(node) {
                while (node.left) { node = node.left; }
                return node;
            }

            search(node, value) {
                if (!node || node.value === value) { return node; }
                if (value < node.value) { return this.search(node.left, value); }
                return this.search(node.right, value);
            }
        }

        const tree = new RedBlackTree();
        const canvas = document.getElementById('tree-canvas');
        const ctx = canvas.getContext('2d');
        let showNullNodes = false;
        let animationComplete = true; 

        // --- Global Control Functions ---
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            tree.updateDisplay();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function prevStep() {
            if (!animationComplete) return; 
            if (fixupInterval) clearInterval(fixupInterval); 
            tree.loadState(tree.currentStepIndex - 1);
        }

        function nextStep() {
            if (!animationComplete) return;
            if (fixupInterval) clearInterval(fixupInterval); 
            tree.loadState(tree.currentStepIndex + 1);
        }
        
        function runOperation(operationFunc) {
            if (!animationComplete) return;
            if (fixupInterval) clearInterval(fixupInterval); 
            operationFunc();
            tree.updateDisplay(true); 
        }

        function insertNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            runOperation(() => tree.insert(value));
            document.getElementById('nodeValue').value = '';
        }

        function deleteNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            runOperation(() => tree.delete(value));
            document.getElementById('nodeValue').value = '';
        }

        function clearTree() {
            runOperation(() => {
                tree.root = null;
                tree.saveState('Tree cleared');
                tree.nodeToFix = null;
            });
        }

        function toggleNullNodes() {
            showNullNodes = !showNullNodes;
            document.getElementById('nullToggle').classList.toggle('active');
            tree.updateDisplay();
        }

        function toggleTheme() {
            document.body.classList.toggle('light-theme');
            document.getElementById('themeToggle').classList.toggle('active');
            tree.updateDisplay();
        }

        // --- Canvas Drawing and Animation Functions (New Layout Logic) ---
        function calculateLevels(node) {
            if (!node) return;
            const queue = [{ node: node, level: 0 }];
            while (queue.length > 0) {
                const { node: currentNode, level } = queue.shift();
                currentNode.level = level; 
                if (currentNode.left) queue.push({ node: currentNode.left, level: level + 1 });
                if (currentNode.right) queue.push({ node: currentNode.right, level: level + 1 });
            }
        }

        function calculatePositions(node, canvasWidth) {
            if (!node) return;

            const levels = new Map();
            let maxLevel = 0;

            // Perform a BFS to populate levels and find max level
            const queue = [{ node: node, level: 0 }];
            while (queue.length > 0) {
                const { node: currentNode, level } = queue.shift();
                maxLevel = Math.max(maxLevel, level);

                if (!levels.has(level)) {
                    levels.set(level, []);
                }
                levels.get(level).push(currentNode);

                if (currentNode.left) queue.push({ node: currentNode.left, level: level + 1 });
                if (currentNode.right) queue.push({ node: currentNode.right, level: level + 1 });
            }

            let maxSlots = 0;
            for (let level = 0; level <= maxLevel; level++) {
                let currentLevelSlots = 0;
                for (const n of levels.get(level) || []) {
                    currentLevelSlots++; 
                    if (showNullNodes) {
                        if (!n.left) currentLevelSlots++;
                        if (!n.right) currentLevelSlots++;
                    }
                }
                maxSlots = Math.max(maxSlots, currentLevelSlots);
            }

            if (tree.root && maxSlots === 0) {
                maxSlots = showNullNodes ? 3 : 1; 
            } else if (maxSlots === 0) {
                maxSlots = 1;
            }

            const NODE_RADIUS = 25;
            const minHorizontalSpacing = NODE_RADIUS * 2 + 30; 
            let totalTreeWidth = maxSlots * minHorizontalSpacing;

            const scaleFactor = Math.min(1, canvasWidth / (totalTreeWidth + minHorizontalSpacing)); 
            const horizontalSpacing = minHorizontalSpacing * scaleFactor;
            
            const startX = (canvasWidth - totalTreeWidth * scaleFactor) / 2 + horizontalSpacing / 2;

            let currentXSlot = 0;
            const horizontalOffsets = new Map();

            function inOrderAssignX(n, level) {
                if (!n) {
                    if (showNullNodes) { currentXSlot++; }
                    return;
                }

                inOrderAssignX(n.left, level + 1);

                horizontalOffsets.set(n, currentXSlot);
                currentXSlot++;

                inOrderAssignX(n.right, level + 1);
            }
            
            inOrderAssignX(node, 0); 

            const verticalSpacing = Math.min(80, canvas.height / (maxLevel + 2)); 

            const allNodes = [];
            const collectNodes = (n) => {
                if (n) {
                    allNodes.push(n);
                    collectNodes(n.left);
                    collectNodes(n.right);
                }
            };
            collectNodes(node);

            for (const n of allNodes) {
                const assignedSlot = horizontalOffsets.get(n);
                n.targetX = startX + assignedSlot * horizontalSpacing;
                n.targetY = 50 + n.level * verticalSpacing; 

                if (!n.x) n.x = n.targetX;
                if (!n.y) n.y = n.targetY;
            }
        }


        function animateTree() {
            if (!tree.root) {
                drawTree();
                return;
            }
            
            animationComplete = false;
            
            calculateLevels(tree.root);
            calculatePositions(tree.root, canvas.width);

            const speedSlider = document.getElementById('animationSpeed');
            const animationFactor = parseFloat(speedSlider.value) / 100 * 0.2 + 0.02; 

            function animate() {
                let allInPlace = true;
                
                function updateNode(node) {
                    if (!node) return;
                    
                    const dx = node.targetX - node.x;
                    const dy = node.targetY - node.y;
                    
                    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                        node.x += dx * animationFactor;
                        node.y += dy * animationFactor;
                        allInPlace = false;
                    } else {
                        node.x = node.targetX;
                        node.y = node.targetY;
                    }
                    
                    updateNode(node.left);
                    updateNode(node.right);
                }
                
                updateNode(tree.root);
                drawTree();
                
                if (!allInPlace) {
                    requestAnimationFrame(animate);
                } else {
                    animationComplete = true; 
                }
            }
            
            requestAnimationFrame(animate);
        }

        function drawTree() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!tree.root) {
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text-secondary');
                ctx.font = '20px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Tree is empty', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            drawConnections(tree.root);
            drawNode(tree.root);
        }

        function drawConnections(node) {
            if (!node) return;
            
            const styles = getComputedStyle(document.body);
            ctx.strokeStyle = styles.getPropertyValue('--border');
            ctx.lineWidth = 2;
            
            const RADIUS = 25; 
            const verticalSpacing = 80; 

            function getLinkPoints(fromX, fromY, toX, toY, radius) {
                const angle = Math.atan2(toY - fromY, toX - fromX);
                return {
                    startX: fromX + Math.cos(angle) * radius,
                    startY: fromY + Math.sin(angle) * radius,
                    endX: toX - Math.cos(angle) * radius,
                    endY: toY - Math.sin(angle) * radius,
                };
            }
            
            if (node.left) {
                const points = getLinkPoints(node.x, node.y, node.left.x, node.left.y, RADIUS);
                ctx.beginPath();
                ctx.moveTo(points.startX, points.startY);
                ctx.lineTo(points.endX, points.endY);
                ctx.stroke();
                drawConnections(node.left);
            } else if (showNullNodes) {
                const nullX = node.x - 30;
                const nullY = node.y + verticalSpacing - 20; 
                ctx.beginPath();
                ctx.moveTo(node.x, node.y + RADIUS);
                ctx.lineTo(nullX, nullY);
                ctx.stroke();
                drawNullNode(nullX, nullY);
            }
            
            if (node.right) {
                const points = getLinkPoints(node.x, node.y, node.right.x, node.right.y, RADIUS);
                ctx.beginPath();
                ctx.moveTo(points.startX, points.startY);
                ctx.lineTo(points.endX, points.endY);
                ctx.stroke();
                drawConnections(node.right);
            } else if (showNullNodes) {
                const nullX = node.x + 30;
                const nullY = node.y + verticalSpacing - 20; 
                ctx.beginPath();
                ctx.moveTo(node.x, node.y + RADIUS);
                ctx.lineTo(nullX, nullY);
                ctx.stroke();
                drawNullNode(nullX, nullY);
            }
        }

        function drawNode(node) {
            if (!node) return;
            
            const radius = 25;
            const styles = getComputedStyle(document.body);
            
            ctx.beginPath();
            ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = node.color === 'RED' ? 
                styles.getPropertyValue('--red-node') : 
                styles.getPropertyValue('--black-node');
            ctx.fill();
            ctx.strokeStyle = styles.getPropertyValue('--border');
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.value, node.x, node.y);
            
            drawNode(node.left);
            drawNode(node.right);
        }

        function drawNullNode(x, y) {
            const radius = 15;
            const styles = getComputedStyle(document.body);
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = styles.getPropertyValue('--null-node');
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('N', x, y);
        }

        document.getElementById('nodeValue').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                insertNode();
            }
        });

        // Initial draw
        tree.updateDisplay();
    </script>
</body>
</html>